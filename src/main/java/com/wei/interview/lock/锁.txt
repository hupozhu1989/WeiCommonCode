公平锁
    是指多个线程按照申请锁的顺序来获取锁类似排队打饭 先来后到
非公平锁
    是指在多线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象
    并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁 默认是非公平锁,非公平锁的优点在于吞吐量必公平锁大
    对于synchronized而言,也是一种非公平锁
可重入锁(递归锁):
    同一个线程在外层方法获取锁后,进入内层方法将自动获得锁.可重入锁最大的作用就是避免死锁
自旋锁(SpinLock):
    指尝试获取锁的线程不会立即阻塞,而是采用循环的方式去尝试获取锁,好处是减少线程上下文切换的消耗,缺点是循环会消耗CPU
独占锁/共享锁/互斥锁
    独占锁:该锁一次只能被一个线程所持有
    共享锁:该锁可被多个线程所持有
    对ReentrantReadWriteLock而言,其读锁是共享锁,写锁是独占锁,读锁的共享锁可以保证并发的高效性,读写、写读、写写的过程是互斥的
读写锁 ReentrantReadWriteLock


偏向锁,严格意义上不是锁,就是个标志,没有竞争,第一个进来的
    ↓(升级)↓
轻量级自旋锁,是一把竞争锁,自旋发生在用户空间(用户态),等待时消耗cpu资源
	↓(升级)↓
重量级锁,调用.wait()/.notify()的时候已经是重量级状态了,内核空间(内核态),等待时不消耗cpu资源,
升级机制:线程超过10次自旋,-XX:PreBlockSpin,或者自旋线程数超过CPU核数的一半,1.6之后,加入自适应自旋Adaptive Self Spinning,由jvm自己控制

AQS核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，
那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤CLH队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。