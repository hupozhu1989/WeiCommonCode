https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md
公平锁
    是指多个线程按照申请锁的顺序来获取锁类似排队打饭 先来后到
非公平锁
    是指在多线程获取锁的顺序并不是按照申请锁的顺序,有可能后申请的线程比先申请的线程优先获取到锁,在高并发的情况下,有可能造成优先级反转或者饥饿现象
    并发包ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或者非公平锁 默认是非公平锁,非公平锁的优点在于吞吐量必公平锁大
    对于synchronized而言,也是一种非公平锁
可重入锁(递归锁):
    同一个线程在外层方法获取锁后,进入内层方法将自动获得锁.可重入锁最大的作用就是避免死锁
自旋锁(SpinLock):
    指尝试获取锁的线程不会立即阻塞,而是采用循环的方式去尝试获取锁,好处是减少线程上下文切换的消耗,缺点是循环会消耗CPU
独占锁/共享锁/互斥锁
    独占锁:该锁一次只能被一个线程所持有
    共享锁:该锁可被多个线程所持有
    对ReentrantReadWriteLock而言,其读锁是共享锁,写锁是独占锁,读锁的共享锁可以保证并发的高效性,读写、写读、写写的过程是互斥的
读写锁 ReentrantReadWriteLock


偏向锁,严格意义上不是锁,就是个标志,没有竞争,第一个进来的
    ↓(升级)↓
轻量级自旋锁,是一把竞争锁,自旋发生在用户空间(用户态),等待时消耗cpu资源
	↓(升级)↓
重量级锁,调用.wait()/.notify()的时候已经是重量级状态了,内核空间(内核态),等待时不消耗cpu资源,
升级机制:线程超过10次自旋,-XX:PreBlockSpin,或者自旋线程数超过CPU核数的一半,1.6之后,加入自适应自旋Adaptive Self Spinning,由jvm自己控制


>>线程间的同步的⽅式有哪些呢?
线程同步是两个或多个共享关键资源的线程的并发执⾏。应该同步线程以避免关键的资源使⽤冲突。操作系统⼀般有下⾯三种线程同步的⽅式：
1.互斥量(Mutex)：采⽤互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有⼀个，所以可以保证公共资源不会被多个线程同时访问。
⽐如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2.信号量(Semaphore)：它允许同⼀时刻多个线程访问同⼀资源，但是需要控制同⼀时刻访问此资源的最⼤线程数量
3.事件(Event)：Wait/Notify：通过通知操作的⽅式来保持多线程同步，还可以⽅便的实现多线程优先级的⽐较操作


AQS是⼀个⽤来构建锁和同步器的框架(AbstractQueuedSynchronizer)，使⽤AQS能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，⽐如我们提到的ReentrantLock、
Semaphore，其他的诸如ReentrantReadWriteLock、SynchronousQueue、FutureTask等等皆是基于AQS的。当然，我们⾃⼰也能利⽤AQS⾮常轻松容易地
构造出符合我们⾃⼰需求的同步器。
AQS核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，
那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤CLH队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。
CLH(Craig,Landin,and Hagersten)队列是⼀个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。
AQS是将每条请求共享资源的线程封装成⼀个CLH锁队列的⼀个结点（Node）来实现锁的分配。
